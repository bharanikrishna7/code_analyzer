INTRODUCTION:
-------------
Code analysis consists of extracting lexical content from source code files, ana
In this project we will build and test a dependency analyzer in C++ that consists of following packages:
1. Tokenizer :
Extracts words, called tokens, from a stream of characters. Token boundaries are white-space characters, transitions between alphanumeric and punctuator characters, and comment and string boundaries. Certain classes of punctuator characters belong to single character or two character tokens so they require special rules for extraction.

2. SemiExpression :
Groups tokens into logical sets, each of which contain information needed to know the purpose of the collective set of tokens. Each of the semi-expressions end at one of the following tokens {, }, ; 
The ; token will not cause problems to detect for loop in semi-expressions.
ex: Declarations -> int A = 60; 
ex: Definition -> struct _stru {
ex: Conditions -> if(A > 50) {

3. Parser :
Parser will contain action and rules which will help to detect class, structures, namespace, enumerators. These scopes will be stored in an Abstract Syntax Tree, this is done to visualize the scopes and the structure of the code. Also all the above scopes and typedef & aliases will be stored in a Partial Type Table which will be used for dependency analysis.

4. Metrics :
Metrics package will be responsible for building the AST and Partial Type Table using the Parser project.

5. Metric Exec (Depreciated) :
This package was used to build AST for a bunch of files. (It is not being used now)

6. GetTypeTable :
This package will be responsible for merging all the partial type tables into a single Final Type Table which is of type std::unordered_map

7. AnalyzeFile :
This package will be using the final type table generated by the GenTypeTable package and it will try to find the dependency of the current file on the other files from the final typetable. 

8. ParallelDependencyAnalysis :
This package will execute in 2 passes. The 1st pass will use GetTypeTable package to generate final type table, while the 2nd pass will be using AnalyzeFile package which will analyze a file to find out the files it depends on. All these dependency results are displayed to console.

9. DataStore :
The datastore package provides structure which will help in storing the file path(s). This will be used with FileSystem-Windows package.

10. AST :
The AST package provides a structure for the Abstract Syntax Tree. This will be used by parser to store the Abstract Syntax Tree.

11. ScopeStack (Depreciated) :
This was the original package to store the AST, but it has been replaced by AST package.

12. Threadpool :
The threadpool package provides a vector of threads which uses blocking queues to enque the work items. The number of thread queues is decided by the number of threads the computer using this project has. 

13. Tasks :
This package is a wrapper for threadpool package.

14. FileMgr :
This package will help in locating a file in the windows. If the file exists in the specified location, it'll return the absolute path to the file.

15. FileSystem-Windows :
This package will help to locate files in a specified path with specified pattern. For our purpose we will be having pattern as *.cpp *.h since we want to get all the files associated with C++ language.

16. Utilities :
This package will provide functions like title, trim etc to help other packages.

17. ParallelDependencyExec :
This package is there to run tests and display the features of this project.

Build:
------
To generate a .bat file which will run this program :-

1. To use this solution Visual Studio (2015 or newer) will be required. 
2. Run compile.bat through Visual Studio Developer Console to generate build the solution.
3. To execute the program again using Visual Studio Developer Console execute run.bat

Standard Visual Studio IDE Build :-

1. Set the default project and define appropriate variable to include the main of the program which is supposed to be executed. Also disable other main() by commenting out the defined variable.
2. Execute the program "using start without debugging"

LIMITATIONS OF PROJECT:
-----------------------
1. This project will not work when there are multiple types (function / class / alias / typedef / struct / enum) with same name.
2. Will not understand method overloading.
3. Will give false dependencies when a token matching the entry in Final Type Table is found 
   ex : Suppose final type table has an entry {A , namespace, global, file1.cpp }
		Now if file2.cpp has a semi-expression => int A;
		
		This program will say file2.cpp depends on file1.cpp which is incorrect. This happens since
		it finds a matching token and it doesnot (no functions present) analyze what type of token it
		got.

		
FOR TESTING:
-------------
1. The test files are placed in Test folder.
2. For better understanding use VERBOSE Mode.
   Can be done by setting VERBOSE variable to true in ParallelDependencyExec